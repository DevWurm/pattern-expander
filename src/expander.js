// @flow

/**
 * class for describing an expansion rule
 *
 * @access public
 *
 * @param variable {String} the variable, which should be expanded
 * @param values  {Array} the elements, which should be the source for expansion. If ommitted, from and to must be specified.
 * @param from {Number} the beginning of a number range, which should be the source for expansion. Must be omitted, if range is specified.
 * @param to {Number} the end of a number range, which should be the source for expansion. Must be omitted, if range is specified.
 *
 * @return {Range} the range element
 */
export class Rule {
    constructor(variable, from, to, padChar) {
        this._variable = variable;
        if (from && to && !from instanceof Array) {
            // if a range is provided, generate the corresponding values
            this._values = Array.apply(null, {length: Number(to) - Number(from) + 1}).map((val, key) => Number(from) + key);
            this._padChar = padChar ? padChar : '0';
        } else if (from instanceof Array) {
            // if an array of values is provide, use the values and move the following arguments one position forward in the arguments list (because 'to' is omitted
            this._values = from;
            this._padChar = to ? to : '0';
        } else {
            throw new Error("Incorrect arguments provided to the Rule constructor");
        }
    }

    get variable() {
        return this._variable;
    }

    get values() {
        return this._values;
    }

    get padChar() {
        return this._padChar;
    }
}

/**
 * applies a set of rules to a pattern, to expand the pattern
 *
 * @access public
 *
 * @param pattern {String / [String]} pattern or array of patterns which will be expanded
 * @param rules {[Rule]} array of rule objects, which specify the expansion.
 *
 * @return {[String]} Array of result identifiers
 */
export function expand(pattern, [rule, ...rules]) {
    const patterns = (pattern instanceof Array) ? pattern : [pattern];

    if (!rule) return patterns;

    return expand([].concat.apply([], patterns.map(pattern => applyRule(pattern, rule))), rules); // [].concat.apply([], arr) flattens arr
}

export default expand;

/**
 * applies a specific rule to expand a pattern
 *
 * @access private
 *
 * @param pattern {String} pattern, which will be expanded
 * @param rule {Object} rule object, which will be applied.
 *
 * @return {[String]} The array of expansion results generated by this rule from the pattern
 */
function applyRule(pattern, {variable, values, padChar}) {
   const regExp = new RegExp(`(${variable}+)`, 'g');

   return values.map(val => {
        let result = ""
        
        let match;
        let chunk = pattern;
        while (match = regExp.exec(chunk)) {
            result += chunk.substr(0, match.index) + pad(val, match[1].length, padChar) + chunk.substr(match.index + match[1].length, (match.lastIndex) ? match.lastIndex : undefined);
            chunk = (match.lastIndex) ? chunk.substr(match.lastIndex) : "";
        }
        
        return result;
   });
}

/**
 * padds a String with preceeding characters, until it has the correct length
 *
 * @access private
 *
 * @param value {String} value, which will be padded
 * @param length {Integer} target length of the value
 * @param padChar {Character (String)} [Optional] character which will be used for padding (default: 0)
 *
 * @return {String} padded value
 */
function pad(value, length, padChar='0') {
        return (value.toString().length < length) ? pad(padChar + value, length, padChar) : value;
}
