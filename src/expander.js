// @flow

/**
 * class for describing an expansion rule
 *
 * @access public
 *
 * @param variable {String} the variable, which should be expanded
 * @param values  {Array} the elements, which should be the source for expansion. If omitted, from and to must be specified.
 * @param from {Number} the beginning of a number range, which should be the source for expansion. Must be omitted, if range is specified.
 * @param to {Number} the end of a number range, which should be the source for expansion. Must be omitted, if range is specified.
 *
 * @return {Range} the range element
 */
export class Rule {
    _variable: string;
    _values: [string];
    _padChar: string;
    
    constructor(variable: string, from: number | [any], to: ?number | ?string, padChar: ?string) {
        this._variable = variable;
        if (from && to && !from instanceof Array) {
            // if a range is provided, generate the corresponding values
            this._values = Array.from(new Array(Number(to) - Number(from) + 1), (val, key) => String(Number(from) + key));
            this._padChar = padChar ? padChar : '0';
        } else if (from instanceof Array) {
            // if an array of values is provide, use the values and move the following arguments one position forward in the arguments list (because 'to' is omitted
            this._values = from;
            this._padChar = to ? String(to) : '0';
        } else {
            throw new Error("Incorrect arguments provided to the Rule constructor");
        }
    }

    get variable(): string {
        return this._variable;
    }

    get values(): [string] {
        return this._values;
    }

    get padChar(): string {
        return this._padChar;
    }
}

/**
 * applies a set of rules to a pattern, to expand the pattern
 *
 * @access public
 *
 * @param pattern {String / [String]} pattern or array of patterns which will be expanded
 * @param rules {[Rule]} array of rule objects, which specify the expansion.
 *
 * @return {[String]} Array of result identifiers
 */
export function expand(pattern: string | [string], rules: [Rule]) {
    const patterns = (pattern instanceof Array) ? pattern : [pattern];

    if (rules.length < 1)  {
        return patterns;
    }

    const rule = rules[0];
    const restRules = rules.slice(1);

    return expand([].concat.apply([], patterns.map(pattern => applyRule(pattern, rule))), restRules); // [].concat.apply([], arr) flattens arr
}

export default expand;

/**
 * applies a specific rule to expand a pattern
 *
 * @access private
 *
 * @param pattern {String} pattern, which will be expanded
 * @param rule {Object} rule object, which will be applied.
 *
 * @return {[String]} The array of expansion results generated by this rule from the pattern
 */
function applyRule(pattern, {variable, values, padChar}: Rule) {
   const regExp = new RegExp(`(${variable}+)`, 'g');

   return values.map(val => {
        let result = "";
        
        let match;
        let chunk = pattern;
        while (match = regExp.exec(chunk)) {
            result += chunk.substr(0, match.index) + pad(val, match[1].length, padChar) + chunk.substr(match.index + match[1].length, (match.lastIndex) ? match.lastIndex : undefined);
            chunk = (match.lastIndex) ? chunk.substr(match.lastIndex) : "";
        }
        
        return result;
   });
}array from

/**
 * padds a String with preceding characters, until it has the correct length
 *
 * @access private
 *
 * @param value {String} value, which will be padded
 * @param length {Number} target length of the value
 * @param padChar {String} [Optional] character which will be used for padding (default: 0)
 *
 * @return {String} padded value
 */
function pad(value: string, length: number, padChar='0') {
        return (value.toString().length < length) ? pad(padChar + value, length, padChar) : value;
}
