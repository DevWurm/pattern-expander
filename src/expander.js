// @flow

/**
 * class for describing an expansion rule
 *
 * The constructor mimics an overloading behavior.
 * You can construct via variable, values, padChar or via variable, from, to, padChar.
 *
 * @access public
 *
 * @param variable {String} the variable, which should be expanded
 * @param values  {Array} the elements, which should be the source for expansion. If omitted, from and to must be specified.
 * @param from {Number} the beginning of a number range, which should be the source for expansion. Must be omitted, if range is specified.
 * @param to {Number} the end of a number range, which should be the source for expansion. Must be omitted, if range is specified.
 *
 * @return {Range} the range element
 */
export class Rule {
    _variable: string;
    _values: [string];
    _padChar: string;
    
    constructor(variable: string, from: number | [any], to: ?number | ?string, padChar: ?string) {
        this._variable = variable;
        if ((from || from === 0) && (to || from === 0) && !(from instanceof Array)) {
            // if a range is provided, generate the corresponding values
            this._values = Array.from(new Array(Number(to) - Number(from) + 1), (val, key) => String(Number(from) + key));
            this._padChar = padChar ? padChar : '0';
        } else if (from instanceof Array) {
            // if an array of values is provide, use the values and move the following arguments one position forward in the arguments list (because 'to' is omitted
            this._values = from.map(val => String(val));
            this._padChar = to ? String(to) : '0';
        } else {
            throw new Error("Incorrect arguments provided to the Rule constructor");
        }
    }

    get variable(): string {
        return this._variable;
    }

    get values(): [string] {
        return this._values;
    }

    get padChar(): string {
        return this._padChar;
    }
}

/**
 * applies a set of rules to a pattern, to expand the pattern
 *
 * @access public
 *
 * @param pattern {String / [String]} pattern or array of patterns which will be expanded
 * @param rules {[Rule]} array of rule objects, which specify the expansion.
 *
 * @return {[String]} Array of result identifiers
 */
export function expand(pattern: string | [string], rules: [Rule]) {
    const patterns = (pattern instanceof Array) ? pattern : [pattern];

    if (rules.length < 1)  {
        return patterns;
    }

    const rule = rules[0];
    const restRules = rules.slice(1);

    return expand([].concat.apply([], patterns.map(pattern => applyRule(pattern, rule))), restRules); // [].concat.apply([], arr) flattens arr
}

export default expand;

/**
 * applies a specific rule to expand a pattern
 *
 * @access private
 *
 * @param pattern {String} pattern, which will be expanded
 * @param rule {Object} rule object, which will be applied.
 *
 * @return {[String]} The array of expansion results generated by this rule from the pattern
 */
function applyRule(pattern, {variable, values, padChar}: Rule) {
   const regExp = new RegExp(`(${variable}+)`, 'g');

   return values.map(val =>  pattern.replace(regExp, (_, match1) => pad(val, match1.length, padChar)));
}

/**
 * padds a String with preceding characters, until it has the correct length
 *
 * @access private
 *
 * @param value {String} value, which will be padded
 * @param length {Number} target length of the value
 * @param padChar {String} [Optional] character which will be used for padding
 *
 * @return {String} padded value
 */
function pad(value: string, length: number, padChar) {
        return (value.toString().length < length) ? pad(padChar + value, length, padChar) : value;
}
